name: Sync Notion Content

on:
  schedule:
    # Run daily at 6 AM UTC (adjust timezone as needed)
    - cron: '0 6 * * *'
  
  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Create content directory
      run: mkdir -p content
      
    - name: Fetch and process Notion content
      env:
        NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
        NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
      run: |
        cat > fetch-notion.js << 'EOF'
        const https = require('https');
        const fs = require('fs');

        const NOTION_TOKEN = process.env.NOTION_TOKEN;
        const PAGE_ID = process.env.NOTION_PAGE_ID;

        // Array to store images that need to be downloaded
        let imagesToDownload = [];

        if (!NOTION_TOKEN || !PAGE_ID) {
          console.error('Missing NOTION_TOKEN or NOTION_PAGE_ID environment variables');
          process.exit(1);
        }

        function fetchNotionBlocks() {
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.notion.com',
              path: `/v1/blocks/${PAGE_ID}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${NOTION_TOKEN}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            const req = https.request(options, (res) => {
              let data = '';
              
              res.on('data', (chunk) => {
                data += chunk;
              });
              
              res.on('end', () => {
                if (res.statusCode === 200) {
                  try {
                    const jsonData = JSON.parse(data);
                    resolve(jsonData);
                  } catch (error) {
                    reject(new Error('Failed to parse JSON response'));
                  }
                } else {
                  reject(new Error(`HTTP error! status: ${res.statusCode}, body: ${data}`));
                }
              });
            });

            req.on('error', (error) => {
              reject(error);
            });

            req.end();
          });
        }

        function fetchBlockChildren(blockId) {
          return new Promise((resolve, reject) => {
            const options = {
              hostname: 'api.notion.com',
              path: `/v1/blocks/${blockId}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${NOTION_TOKEN}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            const req = https.request(options, (res) => {
              let data = '';
              
              res.on('data', (chunk) => {
                data += chunk;
              });
              
              res.on('end', () => {
                if (res.statusCode === 200) {
                  try {
                    const jsonData = JSON.parse(data);
                    resolve(jsonData);
                  } catch (error) {
                    reject(new Error('Failed to parse JSON response'));
                  }
                } else {
                  reject(new Error(`HTTP error! status: ${res.statusCode}, body: ${data}`));
                }
              });
            });

            req.on('error', (error) => {
              reject(error);
            });

            req.end();
          });
        }

        function convertRichText(richTextArray) {
          if (!richTextArray || !Array.isArray(richTextArray)) {
            return '';
          }

          return richTextArray.map(text => {
            let html = text.plain_text || '';
            
            if (text.annotations) {
              if (text.annotations.bold) html = `<strong>${html}</strong>`;
              if (text.annotations.italic) html = `<em>${html}</em>`;
              if (text.annotations.strikethrough) html = `<s>${html}</s>`;
              if (text.annotations.underline) html = `<u>${html}</u>`;
              if (text.annotations.code) html = `<code>${html}</code>`;
            }
            
            if (text.href) {
              html = `<a href="${text.href}" target="_blank">${html}</a>`;
            }
            
            return html;
          }).join('');
        }

        async function handleTableBlock(block) {
          try {
            const tableData = await fetchBlockChildren(block.id);
            const rows = tableData.results;
            
            if (rows.length === 0) {
              return '';
            }

            const hasColumnHeader = block.table.has_column_header;
            const hasRowHeader = block.table.has_row_header;
            
            let html = '<table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">\n';
            
            // Process rows
            rows.forEach((row, rowIndex) => {
              if (row.type !== 'table_row') return;
              
              const cells = row.table_row.cells;
              const isHeaderRow = hasColumnHeader && rowIndex === 0;
              const tag = isHeaderRow ? 'th' : 'td';
              
              html += '  <tr>\n';
              
              cells.forEach((cell, cellIndex) => {
                const cellContent = convertRichText(cell);
                const isHeaderCell = hasRowHeader && cellIndex === 0 && !isHeaderRow;
                const cellTag = isHeaderCell ? 'th' : tag;
                const styles = 'padding: 0.5rem; border: 1px solid var(--border-color, #ddd); text-align: left;';
                const headerStyle = (cellTag === 'th') ? ' background-color: var(--table-header-bg, #f5f5f5); font-weight: bold;' : '';
                
                html += `    <${cellTag} style="${styles}${headerStyle}">${cellContent || '&nbsp;'}</${cellTag}>\n`;
              });
              
              html += '  </tr>\n';
            });
            
            html += '</table>';
            
            return html;
          } catch (error) {
            console.error('Error processing table:', error);
            return '<p>Error loading table</p>';
          }
        }

        async function convertNotionBlockToHTML(block) {
          const type = block.type;
          const content = block[type];

          if (!content) {
            return '';
          }

          switch (type) {
            case 'paragraph':
              const paragraphText = convertRichText(content.rich_text);
              return paragraphText ? `<p>${paragraphText}</p>` : '';
            
            case 'heading_1':
              const h1Text = convertRichText(content.rich_text);
              return h1Text ? `<h1>${h1Text}</h1>` : '';
            
            case 'heading_2':
              const h2Text = convertRichText(content.rich_text);
              return h2Text ? `<h2>${h2Text}</h2>` : '';
            
            case 'heading_3':
              const h3Text = convertRichText(content.rich_text);
              return h3Text ? `<h3>${h3Text}</h3>` : '';
            
            case 'bulleted_list_item':
              const bulletText = convertRichText(content.rich_text);
              return bulletText ? `<li>${bulletText}</li>` : '';
            
            case 'numbered_list_item':
              const numberedText = convertRichText(content.rich_text);
              return numberedText ? `<li>${numberedText}</li>` : '';
            
            case 'quote':
              const quoteText = convertRichText(content.rich_text);
              return quoteText ? `<blockquote>${quoteText}</blockquote>` : '';
            
            case 'divider':
              return '<hr>';
              
            case 'callout':
              const calloutText = convertRichText(content.rich_text);
              return calloutText ? `<div class="callout">${calloutText}</div>` : '';
            
            case 'image':
              return handleImageBlock(block);
            
            case 'table':
              return await handleTableBlock(block);
            
            default:
              const defaultText = convertRichText(content.rich_text || []);
              return defaultText ? `<p>${defaultText}</p>` : '';
          }
        }

        function handleImageBlock(block) {
          const image = block.image;
          let imageUrl = '';
          let caption = '';
          
          // Get image URL based on type
          if (image.type === 'external') {
            imageUrl = image.external.url;
          } else if (image.type === 'file') {
            imageUrl = image.file.url;
          }
          
          // Get caption if exists
          if (image.caption && image.caption.length > 0) {
            caption = convertRichText(image.caption);
          }
          
          if (!imageUrl) {
            return '';
          }
          
          // Generate unique filename for downloaded image
          const imageId = block.id.replace(/-/g, '');
          const extension = imageUrl.includes('.png') ? 'png' : 
                          imageUrl.includes('.gif') ? 'gif' : 
                          imageUrl.includes('.webp') ? 'webp' : 'jpg';
          const filename = `image_${imageId}.${extension}`;
          
          // Store image info for downloading
          imagesToDownload.push({
            url: imageUrl,
            filename: filename,
            caption: caption
          });
          
          // Return HTML with local path
          const imgTag = `<img src="./images/${filename}" alt="${caption}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 1rem 0;">`;
          const captionTag = caption ? `<p class="image-caption" style="text-align: center; font-style: italic; color: var(--text-light); font-size: 0.9rem;">${caption}</p>` : '';
          
          return `<div class="notion-image">${imgTag}${captionTag}</div>`;
        }

        function downloadImage(imageInfo) {
          return new Promise((resolve, reject) => {
            const url = imageInfo.url;
            const filename = imageInfo.filename;
            const filepath = `images/${filename}`;
            
            // Create images directory if it doesn't exist
            if (!fs.existsSync('images')) {
              fs.mkdirSync('images', { recursive: true });
            }
            
            // Skip if file already exists
            if (fs.existsSync(filepath)) {
              console.log(`Image already exists: ${filename}`);
              resolve();
              return;
            }
            
            const https = require('https');
            const file = fs.createWriteStream(filepath);
            
            const request = https.get(url, (response) => {
              if (response.statusCode === 200) {
                response.pipe(file);
                file.on('finish', () => {
                  file.close();
                  console.log(`Downloaded: ${filename}`);
                  resolve();
                });
              } else {
                console.warn(`Failed to download image: ${url} (${response.statusCode})`);
                resolve(); // Continue even if one image fails
              }
            });
            
            request.on('error', (error) => {
              console.warn(`Error downloading image: ${error.message}`);
              resolve(); // Continue even if one image fails
            });
            
            file.on('error', (error) => {
              console.warn(`Error writing image file: ${error.message}`);
              resolve(); // Continue even if one image fails
            });
          });
        }

        function groupListItems(htmlArray) {
          const result = [];
          let currentList = null;
          let currentListType = null;

          htmlArray.forEach(html => {
            if (html.startsWith('<li>')) {
              // Simple approach: treat all <li> as bulleted lists
              // You could enhance this by tracking the original block type
              if (currentListType !== 'ul') {
                if (currentList) {
                  result.push(`</${currentListType}>`);
                }
                currentListType = 'ul';
                result.push('<ul>');
              }
              result.push(html);
            } else {
              if (currentListType) {
                result.push(`</${currentListType}>`);
                currentListType = null;
              }
              if (html.trim()) {
                result.push(html);
              }
            }
          });

          // Close any remaining list
          if (currentListType) {
            result.push(`</${currentListType}>`);
          }

          return result;
        }

        async function main() {
          try {
            console.log('Fetching Notion content...');
            const data = await fetchNotionBlocks();
            
            console.log(`Fetched ${data.results.length} blocks`);
            
            // Reset images array
            imagesToDownload = [];
            
            // Convert blocks to HTML (now async to handle tables)
            const htmlPromises = data.results.map(block => convertNotionBlockToHTML(block));
            const htmlBlocks = await Promise.all(htmlPromises);
            const filteredHtml = htmlBlocks.filter(html => html.trim() !== '');
            
            // Download all images
            if (imagesToDownload.length > 0) {
              console.log(`Downloading ${imagesToDownload.length} images...`);
              await Promise.all(imagesToDownload.map(downloadImage));
            }
            
            // Group list items properly
            const groupedHtml = groupListItems(filteredHtml);
            
            const content = groupedHtml.join('\n');
            
            // Create output object
            const output = {
              content: content,
              lastUpdated: new Date().toISOString(),
              blocksProcessed: data.results.length,
              imagesProcessed: imagesToDownload.length
            };
            
            // Write to file
            fs.writeFileSync('content/notion-content.json', JSON.stringify(output, null, 2));
            
            console.log('Content successfully written to content/notion-content.json');
            console.log(`Processed ${output.blocksProcessed} blocks and ${output.imagesProcessed} images`);
            
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          }
        }

        main();
        EOF
        
        node fetch-notion.js
        
    - name: Commit and push if content changed
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add content/notion-content.json
        git add images/
        
        # Only commit if there are changes
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update Notion content - $(date)"
          git push
        fi
